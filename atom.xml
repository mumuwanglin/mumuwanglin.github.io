<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://mumuwanglin.github.io</id>
    <title>木木的个人小站</title>
    <updated>2022-07-27T08:30:26.688Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://mumuwanglin.github.io"/>
    <link rel="self" href="https://mumuwanglin.github.io/atom.xml"/>
    <subtitle>每天进步一点点</subtitle>
    <logo>https://mumuwanglin.github.io/images/avatar.png</logo>
    <icon>https://mumuwanglin.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 木木的个人小站</rights>
    <entry>
        <title type="html"><![CDATA[七猫 iOS 启动时间优化]]></title>
        <id>https://mumuwanglin.github.io/post/qi-mao-ios-qi-dong-shi-jian-you-hua/</id>
        <link href="https://mumuwanglin.github.io/post/qi-mao-ios-qi-dong-shi-jian-you-hua/">
        </link>
        <updated>2021-08-06T12:34:33.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>随着产品的迭代，产品功能越来越多， App 大小越来越大，导致越来越多的体验和性能问题，其中用户首先感知的肯定是启动速度。传统的启动优化有减少不必要代码，懒加载动态库，任务优先级划分等，此类相关优化的策略已经很普遍了，这些优化主要是从减少主线程任务的角度来出发，很难再做出大的提升。</p>
<h2 id="app-启动时都做了些什么">App 启动时都做了些什么？</h2>
<p>一般而言，App 的启动时间，指的是从用户点击 App 开始，到用户看到第一个界面之间的时间。启动主要包括三个阶段：</p>
<ol>
<li>main() 函数执行前；</li>
<li>main() 函数执行后；</li>
<li>首屏渲染完成后。<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210806204606.png" alt="" loading="lazy"></li>
</ol>
<h3 id="main函数之前">main函数之前</h3>
<p>WWDC 2016 Session 406优化应用程序启动时间详细介绍了每个步骤以及改进时间的提示，以下是简要的总结说明：</p>
<ol>
<li>dylib loading time: 动态加载程序查找并读取应用程序使用的依赖动态库。每个库本身都可能有依赖项。虽然苹果系统框架的加载是高度优化的，但加载嵌入式框架可能会很耗时。为了加快动态库的加载速度，苹果建议您使用更少的动态库，或者考虑合并它们
<ul>
<li>建议的目标是六个额外的(非系统)框架</li>
</ul>
</li>
<li>Rebase/binding time：修正调整镜像内的指针(重新调整)和设置指向镜像外符号的指针(绑定)。为了加快重新定位/绑定时间，我们需要更少的指针修复。
<ul>
<li>如果有大量(大的是20000)Objective-C类、选择器和类别的应用程序可以增加800ms的启动时间。</li>
<li>如果应用程序使用C++代码，那么使用更少的虚拟函数。</li>
<li>使用Swift结构体通常也更快。</li>
</ul>
</li>
<li>ObjC setup time：Objective-C运行时需要进行设置类、类别和选择器注册。我们对重新定位绑定时间所做的任何改进也将优化这个设置时间。</li>
<li>initializer time：运行初始化程序。如果使用了Objective-C的 +load 方法，请将其替换为 +initialize 方法。</li>
</ol>
<h3 id="main函数">main函数</h3>
<p>main函数执行后的阶段，指的是从 main函数执行开始，到 AappDelegate 的 didFinishLaunchingWithOptions 方法里首屏渲染相关方法执行完成。</p>
<h3 id="首屏渲染完成后">首屏渲染完成后</h3>
<p>首屏渲染后的这个阶段，主要完成的是，非首屏其他业务服务模块的初始化、监听的注册、配置文件的读取等。</p>
<h2 id="减少main函数前的dyld的加载">减少main函数前的dyld的加载</h2>
<h3 id="如何统计各个阶段的执行时间">如何统计各个阶段的执行时间？</h3>
<p>Xcode 为我们提供了一个参数<code>DYLD_PRINT_STATISTICS</code>，配置完成后，就可以获取 pre-main 各个阶段的时间。<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807103014.png" alt="" loading="lazy"><br>
运行一下工程，控制台会输出以下内容：</p>
<pre><code>Total pre-main time: 1.1 seconds (100.0%)
         dylib loading time: 296.28 milliseconds (25.3%)
        rebase/binding time: 135.08 milliseconds (11.5%)
            ObjC setup time:  71.43 milliseconds (6.1%)
           initializer time: 664.75 milliseconds (56.9%)
           slowest intializers :
             libSystem.B.dylib :  14.72 milliseconds (1.2%)
                      YYReader : 668.40 milliseconds (57.2%)
</code></pre>
<p>在减少十个动态库后，使用 iPhone 7 测试十组启动数据：<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807154146.png" alt="" loading="lazy"><br>
看出来，使用静态库确实可以减少一部分的启动时候，而且减少的动态库越多，效果越明显。</p>
<h3 id="动态库和静态库对比">动态库和静态库对比</h3>
<table>
<thead>
<tr>
<th>库类型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态库</td>
<td>1、链接时会完整的复制到 mach-o 中 <br> 2、由系统一次性加载，效率更高</td>
<td>1. 会使主 mach-o 文件增大</td>
</tr>
<tr>
<td>动态库</td>
<td>1、 无需拷贝到主 mach-o 文件中，主 mach-o 体积小 <br> 2、可运多个应用程序共享内存中得同一份库文件，节省资源</td>
<td>1. 需要额外加载动态库，造成性能损耗 <br> 2、动态库在程序运行时由系统动态加载到内存，供程序调用，如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行</td>
</tr>
</tbody>
</table>
<h3 id="动态库如何修改为静态库">动态库如何修改为静态库？</h3>
<ol>
<li>在公司的git仓库中创建一个私有项目，用于存放私有podspec</li>
<li>在<code>Alamofire</code>开源代码中找到原作者提供的<code>podspec</code>文件</li>
</ol>
<pre><code>Pod::Spec.new do |s|
  s.name = 'Alamofire'
  s.version = '4.8.1'
  s.license = 'MIT'
  s.summary = 'Elegant HTTP Networking in Swift'
  s.homepage = 'https://github.com/Alamofire/Alamofire'
  s.social_media_url = 'http://twitter.com/AlamofireSF'
  s.authors = { 'Alamofire Software Foundation' =&gt; 'info@alamofire.org' }
  s.source = { :git =&gt; 'https://github.com/Alamofire/Alamofire.git', :tag =&gt; s.version }
  s.documentation_url = 'https://alamofire.github.io/Alamofire/'

  s.ios.deployment_target = '8.0'
  s.osx.deployment_target = '10.10'
  s.tvos.deployment_target = '9.0'
  s.watchos.deployment_target = '2.0'
  
  s.source_files = 'Source/*.swift'
end
</code></pre>
<ol start="3">
<li>拷贝作者的podspec文件，在文件中加入支持静态库打包的代码</li>
</ol>
<pre><code>Pod::Spec.new do |s|
  s.name = 'Alamofire'
  s.version = '4.8.1'
  s.license = 'MIT'
  s.summary = 'Elegant HTTP Networking in Swift'
  s.homepage = 'https://github.com/Alamofire/Alamofire'
  s.social_media_url = 'http://twitter.com/AlamofireSF'
  s.authors = { 'Alamofire Software Foundation' =&gt; 'info@alamofire.org' }
  s.source = { :git =&gt; 'https://github.com/Alamofire/Alamofire.git', :tag =&gt; s.version }
  s.documentation_url = 'https://alamofire.github.io/Alamofire/'

  s.ios.deployment_target = '8.0'
  s.osx.deployment_target = '10.10'
  s.tvos.deployment_target = '9.0'
  s.watchos.deployment_target = '2.0'
  
  # 支持静态库打包
  s.static_framework = true
  s.source_files = 'Source/*.swift'
end
</code></pre>
<ol start="4">
<li>将新生成的文件放入私有仓库中 为了与线上版本进行准确区分可以搞一个特殊的版本号</li>
<li>在Pod中引入私有仓库 pod集成特定版本的项目即可</li>
</ol>
<h2 id="clang插桩实现二进制重排">Clang插桩实现二进制重排</h2>
<p>自从抖音分析了<a href="https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a>文章, 二进制重排优化 pre-main 阶段的启动时间自此被大家广为流传 。抖音采用的是静态扫描+运行时trace的方案，目前仍存一些问题：<strong>hook Objc_msgSend 无法解决的 纯swift , block , c++ 方法</strong>。<br>
通过调研，我们发现clang 插桩的方式可以完美解决抖音遇到问题。</p>
<h3 id="原理">原理</h3>
<ol>
<li>Page Fault<br>
进程如果能直接访问物理内存无疑是很不安全的，所以操作系统在物理内存的上又建立了一层虚拟内存。为了提高效率和方便管理，又对虚拟内存和物理内存又进行分页（Page）。当进程访问一个虚拟内存Page而对应的物理内存却不存在时，会触发一次缺页中断（Page Fault），分配物理内存，有需要的话会从磁盘mmap读取数据。</li>
</ol>
<p>通过App Store渠道分发的App，Page Fault还会进行签名验证，所以一次Page Fault的耗时比想象的要多：<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807111357.png" alt="" loading="lazy"></p>
<p>查看 Page Fault 的数量<br>
我们用到 Instruments 中的 System Trace工具<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807113345.png" alt="" loading="lazy"></p>
<ol>
<li>重排<br>
编译器在生成二进制代码的时候，默认按照链接的Object File(.o)顺序写文件，按照Object File内部的函数顺序写函数<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807111527.png" alt="" loading="lazy"></li>
</ol>
<p>但如果我们把method1、method5、method6排布到一起，那么只需要一个Page Fault即可，这就是二进制文件重排的核心原理<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807111553.png" alt="" loading="lazy"></p>
<p>iOS App之所以能够使用二进制重排，是因为Xcode 已经提供好这个机制 , 并且 <a href="https://opensource.apple.com/tarballs/objc4/">libobjc</a> 实际上也是用了二进制重排进行优化 .<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807111842.png" alt="" loading="lazy"></p>
<ol>
<li>获取启动加载所有的函数的符号<br>
如何获取所有的符号信息？
<ul>
<li>Hook： oc 或者 swift @objc dynamic 修饰的方法，调用都会通过 objc_MsgSend 发送消息，hook objc_MsgSend 可以做到这个方法的检测。但如果是可变参数个数，则需要汇编来获取参数</li>
<li>二进制静态扫描： Mach-O文件在特定段Segment和Section里存储着符号及函数数据，通过静态扫描Mach-O文件，主要是分析获取load方法和c++ constructor 构造方法。<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807112557.png" alt="" loading="lazy"></li>
<li>clang 汇编插桩： clang 本身已经提供了一个代码覆盖率检测机制<a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a></li>
</ul>
</li>
</ol>
<h3 id="实施">实施</h3>
<ol>
<li>clang 插桩<br>
使用 clang 自带的 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html">SanitizerCoverage</a> 工具<br>
新建一个测试工程：Xcode -&gt; Build Setting -&gt; Other C Flags，添加 <code>-fsanitize-coverage=trace-pc-guard</code><br>
注： 如果项目内使用了 Swift， 需要在 Other Swift Flags <code> -sanitize-coverage=func 和 -sanitize=undefined__</code><br>
在 ViewController.m 中添加SanitizerCoverage中代码</li>
</ol>
<pre><code>#include &lt;stdint.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sanitizer/coverage_interface.h&gt;

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
  static uint64_t N;  // Counter for the guards.
  if (start == stop || *start) return;  // Initialize only once.
  printf(&quot;INIT: %p %p\n&quot;, start, stop);
  for (uint32_t *x = start; x &lt; stop; x++)
    *x = ++N;  // Guards should start from 1.
}

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
  if (!*guard) return;  // Duplicate the guard check.
//  void *PC = __builtin_return_address(0);
  char PcDescr[1024];
//  __sanitizer_symbolize_pc(PC, &quot;%p %F %L&quot;, PcDescr, sizeof(PcDescr));
  printf(&quot;guard: %p %x PC %s\n&quot;, guard, *guard, PcDescr);
}
</code></pre>
<p>运行工程，查看打印<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807114605.png" alt="" loading="lazy"><br>
代码命名 INIT 后面打印的两个指针地址叫 start 和 stop . 那么我们通过 lldb 来查看下从 start 到 stop 这个内存地址里面所存储的到底是啥 .<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807115012.png" alt="" loading="lazy"><br>
发现存储的是从 1 到 14 这个序号 . 那么我们来添加一个 oc 方法 .</p>
<pre><code>- (void)test{
    
}
</code></pre>
<p>发现从 0e 变成了 0f . 也就是说存储的 1 到 14 这个序号变成了 1 到 15 .<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807115141.png" alt="" loading="lazy"><br>
在添加一个 一些函数 ，oe 变成了 11，也就十进制的 17</p>
<pre><code>void(^block)(void) = ^(void){
    
};

void test()
{
    block();
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    test();
}
</code></pre>
<p>也就说明这个stop内存保存的就是工程所有函数的个数.<br>
我们发现，每点击一次屏幕就有3个打印。我们在touchesBegan:touches withEvent:开头设置一个点断，并开启汇编显示(菜单栏Debug→Debug Workflow→Always Show Disassembly)<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807132114.png" alt="" loading="lazy"><br>
可以看出，编译器在touchesBegan前面调用了 __sanitizer_cov_trace_pc_guard函数。<br>
通过断点调试，我们发现每次函数的调用，都会先到__sanitizer_cov_trace_pc_guard函数中来，所以我们可以在 __sanitizer_cov_trace_pc_guard 获取 PC 寄存器，根据 PC 寄存器地址从而获取方法的名称。<br>
拿到了全部的符号之后需要保存，但是由于方法会在各个线程执行，所以不能用数组直接保存数据。所以可以把获取到的数据保存在原子队列中，然后我们从队列获取调用的方法名称。</p>
<pre><code>
#import &lt;libkern/OSAtomic.h&gt;
#import &lt;dlfcn.h&gt;

void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop) {
  static uint64_t N;  // Counter for the guards.
  if (start == stop || *start) return;  // Initialize only once.
  for (uint32_t *x = start; x &lt; stop; x++)
    *x = (uint32_t)++N;  // Guards should start from 1.
}

void __sanitizer_cov_trace_pc_guard(uint32_t *guard) {
    if (!*guard) return;  // Duplicate the guard check.
    // 获取函数__sanitizer_cov_trace_pc_guard调用时下个寄存的地址
    void *PC = __builtin_return_address(0);
    
    // 根据地址获取调用的方法名称
    SymbolNode * node = malloc(sizeof(SymbolNode));
    *node = (SymbolNode){PC, NULL};
    
    // offsetof 用在这里是为了入队添加下一个节点找到 前一个节点next指针的位置
    OSAtomicEnqueue(&amp;symbolList, node, offsetof(SymbolNode, next));
}

static OSQueueHead symbolList = OS_ATOMIC_QUEUE_INIT;

typedef struct {
    void *pc;
    void *next;
} SymbolNode;

+ (BOOL)export {
    NSMutableArray &lt;NSString *&gt;* symbolNames = [NSMutableArray array];
    while (YES) {
        SymbolNode *node = OSAtomicDequeue(&amp;symbolList, offsetof(SymbolNode, next));
        if (node == NULL) {
            break;
        }
        
        Dl_info info;
        dladdr(node-&gt;pc, &amp;info);
        
        NSString * name = @(info.dli_sname);
        // 判读是否是 oc 的方法
        BOOL isObjc = [name hasPrefix:@&quot;+[&quot;] || [name hasPrefix:@&quot;-[&quot;];
        // c 方法前加 _
        NSString * symbolName = isObjc? name : [@&quot;_&quot; stringByAppendingString:name];
        // 去重
        if (![symbolNames containsObject:symbolName]) {
            [symbolNames addObject:symbolName];
        }
    }
    
    // 取反
    NSMutableArray *funcs = [[symbolNames reverseObjectEnumerator] allObjects].mutableCopy;
    // 去除当前方法的 symbols
    [funcs removeObject:[NSString stringWithFormat:@&quot;%s&quot;, __FUNCTION__]];
    
    
    //将结果写入到文件
    NSString * funcString = [funcs componentsJoinedByString:@&quot;\n&quot;];
    NSData * fileContents = [funcString dataUsingEncoding:NSUTF8StringEncoding];
    // 写入指定文件夹
    return [[NSFileManager defaultManager] createFileAtPath:[NSHomeDirectory() stringByAppendingString:@&quot;/lb.roder&quot;] contents:fileContents attributes:nil];
}
</code></pre>
<ol>
<li>
<p>从真机上获取order文件<br>
我们把order文件存在了真机上的tmp文件夹中，要怎么拿到呢？<br>
在<code>Window→Devices And Simulators</code>(快捷键⇧+⌘+2)中：<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807133918.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Xcode 是用的链接器叫做 ld , ld 有一个参数叫 Order File , 我们可以通过这个参数配置一个 order 文件的路径，在这个 order 文件中 , 将你需要的符号按顺序写在里面 ，当工程 build 的时候 , Xcode 会读取这个文件 , 打的二进制包就会按照这个文件中的符号顺序进行生成对应的 mach-O<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807151830.png" alt="" loading="lazy"></p>
</li>
<li>
<p>校验是重排成功<br>
Build Settings中修改Write Link Map File为YES编译后会生成一个Link Map符号表txt文件<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807134152.png" alt="" loading="lazy"><br>
执行⌘ + B构建后，选择Product中的App，在Finder中打开，选择Intermediates.noindex文件夹，找到LinkMap文件，这里是*-LinkMap-normal-arm64.txt。<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807134345.png" alt="" loading="lazy"></p>
</li>
</ol>
<p>对比 txt 文档和 order 文件是否可以匹配<br>
同时可以在 System Trace 工具中查看是否减少。</p>
<h3 id="优化">优化</h3>
<p>由于每次都要要导入重排的源代码，操作很复杂，所以我把上述的一些代码封装成了一个组件 <a href="http://124.243.254.98/wanglin/qmtracingpcs"><br>
QMTracingPCs</a></p>
<p>后续使用起来也分方便</p>
<pre><code>// 第一步
use_frameworks!

platform :ios, '9.0'

target 'QMTracingPCs_Example' do
  pod 'QMTracingPCs'
end

// 第二步
// 如果包含三方库，可以添加如下配置
post_install do |installer|
    require './Pods/QMTracingPCs/QMTracingPCs/Classes/target_track.rb'
    target_track(installer)
end

// 第三步
// 在项目内启动成功的地方，添加如何代码
override func viewDidLoad() {
    super.viewDidLoad()
    let filePath = NSTemporaryDirectory().appending(&quot;/YYTracingPCs.order&quot;)
    QMTracingPCs.exportSymbols(filePath: filePath)
}
</code></pre>
<hr>
<p>同时在这个开源工具中添加了二进制重排预分析工具，只需要切换 target 就可以使用<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807140049.png" alt="" loading="lazy"></p>
<p>使用方式：</p>
<ol>
<li>在 Target -&gt; Build Settings 下，找到 Write Link Map File 来设置输出与否 , 默认是 no .</li>
<li>修改完毕之后，clean 一下，运行工程，Products -&gt; Show in Finder，在mach-o文件上上层目录 __Intermediates.noindex__文件下找到一个txt文件。将其重命名为linked_map.txt</li>
<li>从沙盒路径获取 order 文件，</li>
<li>把 txt 文件和 order 放在 Desktop 文件夹下，配置路径</li>
</ol>
<pre><code>// 链接文件和order文件根目录 注意：换成自己的路径字符串
static let BASE_PATH: String = &quot;/Users/mumu/Desktop&quot;
// 链接文件名
static let LINKED_MAP: String = &quot;linked_map.txt&quot;
// order 文件名
static let LB_ORDER: String = &quot;lb.order&quot;
</code></pre>
<p>控制台输出</p>
<pre><code>linked map __Text(链接文件)：
     起始地址：0x1000051ec
     结束地址：0x101a38c58
     分配的虚拟内存页个数：1677
order symbol(重排文件)：
     需要重排的符号个数：%：1774
     分布的虚拟内存页个数：238
     二进制重排后分布的虚拟内存页个数：21
     内存缺页中断减少的个数：217
     预估节省的时间：108.5 ms
</code></pre>
<p>使用二进制重排之后的工程，再次分别编译出 linked_map.txt 和 lb.order 文件，使用此工具再次运行检查，确认重排效果。</p>
<pre><code>linked map __Text(链接文件)：
     起始地址：0x1000060ac
     结束地址：0x102b0c658
     分配的虚拟内存页个数：2754
order symbol(重排文件)：
     需要重排的符号个数：%：3570
     分布的虚拟内存页个数：71
     二进制重排后分布的虚拟内存页个数：71
     内存缺页中断减少的个数：0
     预估节省的时间：0.0 ms
</code></pre>
<h2 id="pgo-优化">PGO 优化</h2>
<p>PGO(Performance Guided Optimization)， 是 Xoode 提供一种优化方案，但苹果本身的方案放在我们这些采用 CI 工具构建的大型 app 上部署和使用起来较为麻烦，且不利于我们自己去发现分析问题。同时 PGO 是针对 Objective-C 的一种优化方案，对 Swift支持不太好，所有我们就不再做次方面的优化了。<br>
<img src="https://raw.githubusercontent.com/mumuwanglin/PicGo/main/img/20210807141025.png" alt="" loading="lazy"></p>
<h2 id="总结">总结</h2>
<ol>
<li>通过将动态库转为静态库，我们优化了dylib loading time</li>
<li>通过二进制重排，让启动需要的方法排列更紧凑，减少了Page Fault的次数</li>
<li>由于代码逻辑的改动，建议三个月做一次重排，生成一次 order 文件。</li>
</ol>
<p>这篇文章主要讲 pre-mian 之前的一些优化操作，其实 mian 之后也有一些优化操作，比如启动是不必要代码的减少，动态库的懒加载，以及一些非必要启动任务的延后等等。</p>
<h2 id="参考文档">参考文档</h2>
<p><a href="https://opensource.apple.com/tarballs/objc4/">libobjc</a></p>
<p><a href="https://clang.llvm.org/docs/SanitizerCoverage.html">Clang SanitizerCoverage</a></p>
<p><a href="https://mp.weixin.qq.com/s/Drmmx5JtjG3UtTFksL6Q8Q">抖音研发实践：基于二进制文件重排的解决方案 APP启动速度提升超15%</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/396550853?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1337740201394339842&amp;wechatShare=1&amp;s_r=0">脉脉iOS如何启动秒开</a></p>
<p><a href="https://juejin.cn/post/6844904192193085448">懒人版二进制重排</a></p>
<p><a href="https://juejin.cn/post/6844904130406793224">iOS 优化篇 - 启动优化之Clang插桩实现二进制重排</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS开源二进制使用插件(使用教程)]]></title>
        <id>https://mumuwanglin.github.io/post/iOS开源二进制使用插件(使用教程)/</id>
        <link href="https://mumuwanglin.github.io/post/iOS开源二进制使用插件(使用教程)/">
        </link>
        <updated>2021-03-30T07:49:11.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/MeetYouDevs/cocoapods-imy-bin">GitHub 地址</a></p>
<h2 id="概要">概要</h2>
<p>cocoapods-imy-bin功能点：</p>
<ol>
<li>组件二进制化，无入侵式支持组件二进制化，致力于解决Ci打包速度慢、研发编译慢等编译问题。</li>
<li>本地配置文件 - <code>Podfile_local</code></li>
<li>二进制源码调试<code>pod bin code</code>，类似美团 iOS 工程 <code>zsource</code> 命令背后的那些事儿的效果。</li>
<li>命令快捷键<code>pod bin imy</code>，如游戏快捷键，根据配置会在特定目录执行特定命令（如任意终端目录下，执行某个特定目录的pod update --no-repo-update命令），减少其他繁琐操作。支持任意个快捷键。</li>
</ol>
<p>cocoapods-imy-bin插件所关联的组件二进制化策略：</p>
<p>预先将打包成 .a 的组件保存到静态服务器上，并在 install 时，去下载组件对应的二进制版本，以减少组件编译时间，达到加快 App 打包、组件发布等操作的目的。</p>
<p>关于 插件具体的架构部署实践和更详细的资源，可以参考<br>
<a href="https://github.com/su350380433/cocoapods-imy-bin-demo">Demo</a></p>
<h2 id="准备工作">准备工作</h2>
<ol>
<li>
<p>安装插件<br>
<code>sudo gem install cocoapods-imy-bin</code></p>
</li>
<li>
<p>使用二进制组件<br>
<a href="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B">环境搭建详细教程</a></p>
</li>
</ol>
<p>使用二进制时，本插件需要提供以下资源：</p>
<ul>
<li>静态资源服务器（ <a href="https://github.com/su350380433/binary-server">binary-server</a>，附详细使用教程）</li>
<li>二进制私有源仓库（保存组件二进制版本 podspec）</li>
</ul>
<ol start="3">
<li>初始化插件</li>
</ol>
<pre><code>xx:Demo slj$ pod bin init

======  dev 环境 ========

开始设置二进制化初始信息.
所有的信息都会保存在 /Users/slj/.cocoapods/bin_dev.yml 文件中.
%w[bin_dev.yml bin_debug_iphoneos.yml bin_release_iphoneos.yml] 
你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：

---
configuration_env: dev
code_repo_url: git@github.com:su350380433/example_spec_source.git
binary_repo_url: git@github.com:su350380433/example_spec_bin_dev.git
binary_download_url: http://localhost:8080/frameworks/%s/%s.zip
download_file_type: zip


编译环境
可选值：[ dev / debug_iphoneos / release_iphoneos ]
旧值：dev
</code></pre>
<p>按提示输入所属环境、源码私有源、二进制私有源、二进制下载地址、下载文件类型后，插件就配置完成了。其中 binary_download_url 需要预留组件名称与组件版本占位符，插件内部会依次替换 %s 为相应组件的值。</p>
<p>cococapod-bin 也支持从 url 下载配置文件，方便对多台机器进行配置：<br>
<code>pod bin init --bin-url=https://github.com/su350380433/cocoapods-imy-bin-configs/raw/master/bin_dev.yml</code></p>
<p>配置文件模版内容如下，根据不同团队的需求定制即可：</p>
<pre><code>---
configuration_env: dev
code_repo_url: git@github.com:su350380433/example_spec_source.git
binary_repo_url: git@github.com:su350380433/example_spec_bin_dev.git
binary_download_url: http://localhost:8080/frameworks/%s/%s/zip
download_file_type: zip
</code></pre>
<p>配置时，不需要手动添加源码和二进制私有源的 repo，插件在找不到对应 repo 时会主动 clone。</p>
<p>记得启动 sudo mongod服务，静态资源服务。</p>
<h2 id="制作二进制组件">制作二进制组件</h2>
<ol>
<li>制作命令<br>
可以直接使用插件的 <code>pod bin auto</code>命令，在插件初始化配置完成后，目录下只要有包含podspec文件，根据podspec文件的version版本号会自动化执行build、组装二进制组件、制作二进制podspec、上传二进制文件、上传二进制podspec到私有源仓库。</li>
</ol>
<pre><code>pod bin auto
</code></pre>
<p>带上<code>--all-make</code>参数会把当前组件所依赖的组件都自动化制作成二进制组件。</p>
<pre><code>pod bin local
</code></pre>
<p><code>pod bin local </code>是配合其他三方编译产物的命令，需要配置编译产物的目录。</p>
<p>BinArchive.json是制作二进制的一些配置项，放在项目跟目录下：</p>
<pre><code>{
    &quot;//&quot;: &quot;archive-white-pod-list 不制作二进制白名单，&quot;,
    &quot;archive-white-pod-list&quot; : [
        &quot;YYTargetDemo&quot;,
        &quot;YYModel&quot;
    ],
    &quot;//&quot;: &quot;ignore-git-list 不制作二进制 所属git白名单，&quot;,
    &quot;ignore-git-list&quot;: [
        &quot;git@gitlab.xxx.com:Github-iOS&quot;
    ],
     &quot;//&quot;: &quot;ignore-http-list 不制作二进制 所属https白名单，&quot;,
    &quot;ignore-http-list&quot;: [
        &quot;https://gitlab.xxx.com/Github-iOS&quot;
    ],
    &quot;//&quot;: &quot;xcode_build_path 设置编译缓存完整路径, 默认地址如下&quot;,
    &quot;xcode_build_path&quot; : &quot;xcode-build/Build/Intermediates.noindex/ArchiveIntermediates/#{target_name}/IntermediateBuildFilesPath/UninstalledProducts/iphoneos/&quot;,
}
</code></pre>
<ol start="2">
<li>二进制Podspec<br>
通过pod bin auto和pod bin local二进制Podspec 会自动生成、上传，无需关心。</li>
<li>查看结果<br>
二进制存储服务：http://localhost:8080/frameworks/（默认本地8080端口）<br>
二进制私有源参考：https://github.com/su350380433/example_spec_bin_dev.git（自定义）</li>
</ol>
<h2 id="使用二进制">使用二进制</h2>
<p>在Podfile文件中，加入这两行代码，对已经制作二进制的就会生效，自动转换二进制组件依赖。</p>
<pre><code>plugin 'cocoapods-imy-bin'
use_binaries!
</code></pre>
<h2 id="扩展功能">扩展功能</h2>
<ol>
<li>本地组件配置文件 Podfile_local，目前已支持Podfile下的大部分功能，可以把一些本地配置的语句放到Podfile_local。<br>
<img src="https://mumuwanglin.github.io/post-images/1617091839226.webp" alt="" loading="lazy"></li>
</ol>
<p>场景:</p>
<ul>
<li>不希望把本地采用的源码/二进制配置、本地库传到远程仓库。</li>
<li>避免直接修改Podfile文件，引起更新代码时冲突、或者误提交。</li>
</ul>
<p>如Podfile本地库的写法：</p>
<pre><code>pod YYModel :path =&gt; '../' #提交的时候往往要修改回来才提交，操作繁琐
</code></pre>
<p>用法：<br>
在与Podfile同级目录下，新增一个Podfile_local文件,模板可到这里下载Podfile_local</p>
<pre><code>#target 'Seeyou' do 不同的项目注意修改下Seeyou的值
#:path =&gt; '../IMYYQHome',根据实际情况自行修改，与之前在podfile写法一致


 plugin 'cocoapods-imy-bin'
#是否启用二进制插件，想开启把下面注释去掉
# use_binaries! 

#设置使用【源码】版本的组件。
#set_use_source_pods ['YYKit','SDWebImaage']

#需要替换Podfile里面的组件才写到这里
#在这里面的所写的组件库依赖，默认切换为【源码】依赖
target 'Seeyou' do
  #本地库引用
    #pod 'YYModel', :path =&gt; '../YYModel'

  #覆盖、自定义组件
    #pod 'YYCache', :podspec =&gt; 'http://覆盖、自定义/'
end
</code></pre>
<pre><code>以前的 pod update --no-repo-update 命令加个前缀 `bin` 变成
</code></pre>
<pre><code>pod bin update --no-repo-update 
或者
pod bin install
</code></pre>
<p>支持 pod install/update 命令参数</p>
<p>并将其加入 .gitignore ，再也不用担心我误提交或者冲突了，Podfile_local 中的配置选项优先级比 Podfile 高，支持和 Podfile 相同的配置语句，同时支持pre_install or post_install。</p>
<p>如果您不习惯Podfile_local的使用方式，可以把命令写在Podfile里面，pod时不需要加bin，依旧是 pod update/install。</p>
<ol start="2">
<li>二进制源码调试<br>
在项目根目录下，输入命令:</li>
</ol>
<pre><code>pod bin code YYModel
</code></pre>
<p><code>YYModel</code>为需要源码调试的组件库名称。成功之后像平时一样单步调试，控制台打印变量。让我们同时拥有使用二进制的便利和源码调试的能力。</p>
<pre><code>$ pod bin code --help                                                                   [11:37:50]
Usage:

    $ pod bin code [NAME]

      通过将二进制对应源码放置在临时目录中，让二进制出现断点时可以跳到对应的源码，方便调试。 在不删除二进制的情况下为某个组件添加源码调试能力，多个组件名称用空格分隔

Options:

    --all-clean   删除所有已经下载的源码
    --clean       删除所有指定下载的源码
    --list        展示所有一级下载的源码以及其大小
    --source      源码路径，本地路径,会去自动链接本地源码
</code></pre>
<ol start="3">
<li>快捷键命令<br>
在任意的终端执行命令，都能执行特定目录下特定命令<br>
使用命令：</li>
</ol>
<pre><code>pod bin imy
// or
pod bin imy 2    #2 是自定义的快捷键

// 使用场景:
// 在任意目录下，执行项目A的pod update --no-repo-update命令

// 命令快捷键配置
 $ pod bin inithk 

开始设置快捷键 pod bin imy.
所有的信息都会保存在 /Users/ci/.cocoapods/hot_key_1.yml 文件中.
%w[hot_key.yaml] 
你可以在对应目录下手动添加编辑该文件. 文件包含的配置信息样式如下：

---
hot_key_index: '1'
hot_key_dir: '/User/ci/自定义目录'
hot_key_cmd: pod bin update --no-repo-update


快捷键
可选值：[ 1 / 2 / 3... ]
旧值：1 
</code></pre>
<h2 id="dsl参数解释">DSL参数解释</h2>
<p>首先，开发者需要在 <code>Podfile </code>中需要使用 <code>plugin 'cocoapods-imy-bin'</code> 语句引入插件</p>
<p>顺带可以删除 <code>Podfile</code> 中的 <code>source</code> ，因为插件内部会自动帮你添加两个私有源。</p>
<p><code>cocoapods-bin</code>插件提供二进制相关的配置语句有 <code>use_binaries!</code>、<code>use_binaries_with_spec_selector!</code> 以及 <code>set_use_source_pods</code>，下面会分别介绍。</p>
<p>** use_binaries! **<br>
全部组件使用二进制版本。</p>
<p>支持传入布尔值控制是否使用二进制版本，比如 DEBUG 包使用二进制版本，正式包使用源码版本，Podfile 关联语句可以这样写：</p>
<pre><code>use_binaries! (ENV['DEBUG'].nil? || ENV['DEBUG'] == 'true')
</code></pre>
<p>** set_use_source_pods **<br>
设置使用源码版本的组件。<br>
实际开发中，可能需要查看 YYModel 组件的源码，这时候可以这么设置：</p>
<pre><code>set_use_source_pods ['YYModel']
</code></pre>
<p>如果 CocoaPods 版本为 1.5.3 ，终端会输出以下内容，表示 YYModel 的参照源从二进制私有源切换到了源码私有源：</p>
<pre><code>Analyzing dependencies
Fetching podspec for `A` from `../`
Downloading dependencies
Using A (0.1.0)
Installing YYModel 1.0.4.2 (source changed to `git@git.xxxxxx.net:ios/cocoapods-spec.git` from `git@git.xxxxxx.net:ios/cocoapods-spec-binary.git`)
Generating Pods project
Integrating client project
Sending stats
Pod installation complete! There is 1 dependency from the Podfile and 2 total pods installed.
</code></pre>
<p>** use_binaries_with_spec_selector! **<br>
过滤出需要使用二进制版本组件。<br>
假如开发者只需要 <code>YYModel</code> 的二进制版本，那么他可以在 <code>Podfile</code> 中添加以下代码：</p>
<pre><code>use_binaries_with_spec_selector! do |spec|
  spec.name == 'YYModel'
end
</code></pre>
<p>需要注意的是，如果组件有 subspec ，使用组件名作为判断条件应如下：</p>
<pre><code>use_binaries_with_spec_selector! do |spec|
  spec.name.start_with? == '组件名'
end
</code></pre>
<p>如果像上个代码块一样，直接对比组件名，则插件会忽略此组件的所有 <code>subspec</code>，导致资源拉取错误，这种场景下，最好通过 <code>set_use_source_pods</code> 语句配置依赖。<br>
一个实际应用是，三方组件采用二进制版本，团队编写的组件依旧采用源码版本。如果三方组件都在 <code>cocoapods-repo</code> 组下，就可以使用以下代码过滤出三方组件：</p>
<pre><code>use_binaries_with_spec_selector! do |spec|
 git = spec.source &amp;&amp; spec.source['git']
 git &amp;&amp; git.include?('cocoapods-repo')
end
</code></pre>
<p>切换Dev/Debug_iPhoneos/Release_iPhoneos环境初始化设置</p>
<pre><code>#dev 初始化插件配置 默认dev环境
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_dev.yml

#Debug_iPhoneos 初始化插件配置
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_debug_iphoneos.yml


#release_iPhoneos 初始化插件配置
pod bin init --bin-url=https://gitlab.xxx.com/cocoapods-imy-bin-config/raw/master/bin_release_iphoneos.yml
</code></pre>
<p>使用时在podfile 或者 podfile_local指定设置</p>
<pre><code>#在podfile 或者 podfile_local 文件下加这句话
set_configuration_env('debug_iphoneos') 
</code></pre>
<p>** 其他设置 **<br>
插件默认开启多线程下载组件资源，如果要禁用这个功能，Podfile 添加以下代码即可：</p>
<pre><code>install! 'cocoapods', { install_with_multi_threads: false }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift 路由 QMRouter]]></title>
        <id>https://mumuwanglin.github.io/post/swift-lu-you-qmrouter/</id>
        <link href="https://mumuwanglin.github.io/post/swift-lu-you-qmrouter/">
        </link>
        <updated>2020-12-11T06:31:58.000Z</updated>
        <content type="html"><![CDATA[<h2 id="七猫ios组件化架构设计实践">七猫iOS组件化架构设计实践</h2>
<p>一、Service 和 Module 的注册（负责跨模块数据交互）</p>
<ol>
<li>定义夸模块数据交互的协议</li>
</ol>
<p>在Mediator中定义 ModuleService(继承自QMModuleProtocol) 协议</p>
<ul>
<li>定义路由名称</li>
<li>定义此协议需要暴露出的方法</li>
</ul>
<pre><code>// 所有商品的路由
public let kRouteAllGoodsList: String = &quot;freereader://goods/all_goods_list&quot;
// 商品详情的路由
public let kRouteGoodsDetail: String = &quot;qmrouter://goods/detail&quot;
// 跳转商品详情需要传递的参数
public let kRouteGoodsDetailParamId: String = &quot;id&quot;

// 商品类的协议,方便参数的传递
public protocol GoodsProtocol {
    var goodsId: String { get set }
    var name: String { get set }
    var price: Float { get set }
    var inventory: Int { get set }
}

// 商品模块的服务类
public protocol GoodsModuleService: QMModuleProtocol {
    func totalInventory() -&gt; Int
    func popularGoodsList() -&gt; Array&lt;GoodsProtocol&gt;
    func allGoodsList() -&gt; Array&lt;GoodsProtocol&gt;
    func goodsById(goodsId: String) -&gt; GoodsProtocol
}
</code></pre>
<ol start="2">
<li>在 Module 实现定义的 ModuleService 协议 和 QMSharedInstanceProtocol 协议</li>
</ol>
<ul>
<li>实现单例方法</li>
<li>设置初始化优先级(可选)</li>
<li>设置是否异步初始化(可选)</li>
<li>设置 setup 初始化路由(可选)</li>
<li>实现自定义协议的方法</li>
</ul>
<pre><code>final public class GoodsModule: GoodsModuleService,QMSharedInstanceProtocol {
  
    public static var sharedInstance: GoodsModule = GoodsModule()
  
    public func setup() {
        QMRouter.shared.bind(kRouteGoodsDetail) { (params) -&gt; Void in
            let detailVC = GoodsDetailsViewController()
            detailVC.goodsId = params[kRouteGoodsDetailParamId] as? String
          
            // 注册完成后的一些操作
            QMRouter.shared.complete(params, result: &quot;我是成功回调的参数&quot;)
          
            UIViewController.getCurrentVC()?.navigationController?.pushViewController(detailVC, animated: true)
        }
      
        QMRouter.shared.bind(kRouteAllGoodsList) { (params) -&gt; Void in
            let vc = GoodsListViewController()
            UIViewController.getCurrentVC()?.navigationController?.pushViewController(vc, animated: true)
        }
    }
  
    public func totalInventory() -&gt;Int {
        ```
    }
  
    public func popularGoodsList() -&gt; Array&lt;GoodsProtocol&gt; {
        ```
    }
  
    public func allGoodsList() -&gt; Array&lt;GoodsProtocol&gt; {
        ```
    }

    public func goodsById(goodsId: String) -&gt; GoodsProtocol {
        ```
    }


}
</code></pre>
<ol start="3">
<li>注册服务</li>
</ol>
<pre><code>QMRouter.register(GoodsModuleService.self, module: GoodsModule.sharedInstance)
</code></pre>
<ol start="4">
<li>获取服务</li>
</ol>
<pre><code>let goodsModule = QMRouter.module(for: GoodsModuleService.self)
// 获取所有的商品
goodsModule?.allGoodsList()
</code></pre>
<p>二、路由的注册于获取（负责路由的跳转）</p>
<ol>
<li>获取注册的路由</li>
</ol>
<p>在定义的Module 的 setup 方法</p>
<pre><code>final public class GoodsModule: GoodsModuleService,QMSharedInstanceProtocol {
  
    public static var sharedInstance: GoodsModule = GoodsModule()
  
    public func setup() {
        QMRouter.shared.bind(kRouteGoodsDetail) { (params) -&gt; Void in
            let detailVC = GoodsDetailsViewController()
            detailVC.goodsId = params[kRouteGoodsDetailParamId] as? String
  
            // 注册完成后的一些操作
            QMRouter.shared.complete(params, result: &quot;我是成功回调的参数&quot;)
  
            UIViewController.getCurrentVC()?.navigationController?.pushViewController(detailVC, animated: true)
        }
  
        QMRouter.shared.bind(kRouteAllGoodsList) { (params) -&gt; Void in
            let vc = GoodsListViewController()
            UIViewController.getCurrentVC()?.navigationController?.pushViewController(vc, animated: true)
        }
    }
}
</code></pre>
<ol start="2">
<li>获取注册的服务</li>
</ol>
<pre><code>let routeURL = kRouteGoodsDetail

let vc = QMRouter.handle(routeURL, complexParams: [kRouteGoodsDetailParamId: &quot;\(String(describing: goods?.goodsId ?? &quot;&quot;))&quot;]) { (params) in

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift UIScrollView 右侧快速滑块]]></title>
        <id>https://mumuwanglin.github.io/post/swift-uiscrollview-you-ce-kuai-su-hua-kuai/</id>
        <link href="https://mumuwanglin.github.io/post/swift-uiscrollview-you-ce-kuai-su-hua-kuai/">
        </link>
        <updated>2020-10-09T06:30:06.000Z</updated>
        <content type="html"><![CDATA[<p>废话少说，先上链接 <a href="https://github.com/mumuwanglin/YYRightScrollBar">GitHub</a></p>
<h2 id="背景">背景</h2>
<p>系统自带的滚动导航条有点不符合我们的预期要求，所以写了自定义的右侧快速滑块。</p>
<h2 id="实现方案">实现方案</h2>
<p>自定义<code>UIView</code>，给View添加的<code>UIButton</code>，添加手势<code>UIPanGestureRecognizer</code>，计算<code>UIButton</code>在<code>View</code>中间的滚动比例，设置给<code>ScrollView</code>。<br>
<code>ScrollView</code> 开始滚动，计算滚动比例，设置给自定义的<code>View</code></p>
<pre><code>//
//  YYScrollBar.swift
//  YYRightScrollBar
//
//  Created by mumu on 2020/9/16.
//  Copyright © 2020 mumu. All rights reserved.
//

import UIKit

protocol YYScrollBarDelegate: NSObjectProtocol {
    func scrollBarDidScroll(scrollBar: YYScrollBar, rollingRatio: CGFloat)
}

class YYScrollBar: UIView {
    // 滑块滚动的比例
    var scrollViewRotio: CGFloat? {
        didSet {
            showingFastRollingFlag = true
            if isShowFastRollingBtn() {
                followScrollView()
            } else {
                followScrollView()
                showFastRollingBtnWithAnimation()
            }
        }
    }
    
    // 滚动代理
    weak var delegate: YYScrollBarDelegate?
    // 是否展示滑块
    var showingFastRollingFlag = false
    
    // 滑块的宽度
    private var fastRollingWidth: CGFloat = 26
    // 滑块的高度
    private var fastRollingHeight: CGFloat = 42
    private var lastDragPoint: CGFloat = 0
    private var autoHidingFastRollingBtnFlag = true
    
    // 自定义滑块
    lazy var fastRollingButton: UIButton = {
        let tmp = UIButton(type: .custom)
        tmp.frame = CGRect.init(x: 0, y: 0, width: 26, height: 42)
        tmp.setImage(UIImage.init(named: &quot;read_catalog_white_slider&quot;), for: .normal)
        tmp.adjustsImageWhenHighlighted = false
        tmp.isHidden = false
        let panGestureRecognizer = UIPanGestureRecognizer(target: self, action: #selector(handlePan(panGesture:)))
        tmp.addGestureRecognizer(panGestureRecognizer)
        return tmp
    }()
    
    override init(frame: CGRect) {
        super.init(frame: frame)
        setupView()
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    private func setupView() {
        addSubview(fastRollingButton)
    }
    
    // 是否正在展示滑块
    private func isShowFastRollingBtn() -&gt; Bool {
        return fastRollingButton.frame.origin.x == 0
    }
    
    // 更新滑块的位置
    private func updateFasetRollingBtnFrame() {
        self.fastRollingButton.frame = CGRect(x: 0, y: self.fastRollingButton.frame.origin.y, width: self.fastRollingWidth, height: self.fastRollingHeight)
    }
    
    // 显示滑块
    private func showFastRollingBtnWithAnimation() {
        UIView.animate(withDuration: 0.2, animations: {
            self.updateFasetRollingBtnFrame()
        })
    }
    
    // 隐藏滑块
    private func hideFastRollingBtnWithAnimation() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.5, execute: {
            if self.showingFastRollingFlag {
               return
            }
            UIView.animate(withDuration: 0.2, animations: {
                if self.showingFastRollingFlag {
                   return
                }
                let tmpX = self.fastRollingButton.frame.origin.x
                self.fastRollingButton.frame = CGRect(x: tmpX + self.fastRollingWidth, y: self.fastRollingButton.frame.origin.y, width: self.fastRollingWidth, height: self.fastRollingHeight)
            })
        })
    }
    
    // 滚动scrollview 调整快速滑块位置
    private func followScrollView() {
        let rotio = scrollViewRotio ?? 0
        var frame = self.fastRollingButton.frame
        frame.origin.y = (self.frame.size.height - fastRollingHeight) * rotio
        fastRollingButton.frame = frame
    }
    
    // 跟随手势事件
    @objc private func handlePan(panGesture: UIPanGestureRecognizer) {
        if panGesture.state == .ended {
            lastDragPoint = 0
            checkHideFastRollingBtn()
        } else {
            let pointY: CGFloat = panGesture.translation(in: panGesture.view).y
            let offset: CGFloat = pointY - self.lastDragPoint
            lastDragPoint = pointY
            
            var frame = self.fastRollingButton.frame
            let maxY = self.frame.size.height - fastRollingHeight
            
            frame.origin.y = frame.origin.y &gt; maxY ? maxY : frame.origin.y + offset
            frame.origin.y = frame.origin.y &lt;= 0 ? 0 : frame.origin.y
            frame.origin.y = frame.origin.y &gt;= maxY ? maxY : frame.origin.y
            
            self.fastRollingButton.frame = frame
            
            let ratio = frame.origin.y / (self.bounds.size.height - fastRollingHeight)
            delegate?.scrollBarDidScroll(scrollBar: self, rollingRatio: ratio)
        }
    }
    
    // 隐藏滑块
    func checkHideFastRollingBtn() {
        if isShowFastRollingBtn() {
            showingFastRollingFlag = false
            hideFastRollingBtnWithAnimation()
        }
    }
    
    // Scroll滚动，计算滑块位置
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        var scrollViewRotio = scrollView.contentOffset.y/(scrollView.contentSize.height - scrollView.frame.size.height)
        scrollViewRotio = scrollViewRotio &gt;= 1 ? 1 : scrollViewRotio
        scrollViewRotio = scrollViewRotio &lt;= 0 ? 0 : scrollViewRotio
        self.scrollViewRotio = scrollViewRotio
    }
}

</code></pre>
<pre><code>// 使用方法

extension ViewController: YYScrollBarDelegate {
    func scrollBarDidScroll(scrollBar: YYScrollBar, rollingRatio: CGFloat) {
        let offsetY = (tableView.contentSize.height - tableView.frame.size.height) * rollingRatio
        tableView.contentOffset = CGPoint(x: 0, y: offsetY)
    }
}

extension ViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        scrollBar.scrollViewDidScroll(scrollView)
    }
        
    func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {
        scrollBar.checkHideFastRollingBtn()
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[访问swift数组时，swift_isUniquelyReferenced_nonNull_native中的EXC_BAD_ACCESS]]></title>
        <id>https://mumuwanglin.github.io/post/fang-wen-swift-shu-zu-shi-swift_isuniquelyreferenced_nonnull_native-zhong-de-exc_bad_access/</id>
        <link href="https://mumuwanglin.github.io/post/fang-wen-swift-shu-zu-shi-swift_isuniquelyreferenced_nonnull_native-zhong-de-exc_bad_access/">
        </link>
        <updated>2020-09-15T06:29:08.000Z</updated>
        <content type="html"><![CDATA[<h2 id="问题">问题</h2>
<p>场景比较简单：使用一个单例做缓存。单例中加了一个可变字典，用于缓存已经加载过的字体。<br>
根据字体的名称从字典中查找字体对象，当找不到对象的时候就创建一个新的UIFont对象，并保存到字典中。找到对象就直接取现在有的缓存UIFont。</p>
<p>多线程时，MutableDictionary取对象不是元子操作，所以，多个线程请求同一个字体对象时都得到nil。然后就都跑去创建UIFont对象，并都试图保存。创建UIFont对象时，使用imageNamed方法，系统做了优化，进行缓存处理了。<br>
NSMutableDictionary中添加相同的key的时候，会被原来的对象移除。第一个线程保存结束后，此时如果第二个线程试图添加的对象正是第一个线程刚放进去的对象，会出现这样的流程：判断字典中是否有key时成立，然后将对象移除，内存回收，再往字典里写对象时，就等于设置了一个野指针对象。</p>
<h2 id="解决">解决</h2>
<p>使用线程安全的YYCache作为缓存的容器</p>
<pre><code>// 原始代码
private static var cachedFont:[String: UIFont]?

// 缓存字体的方法
private static func getCachedFont(_ fontName: FontType, fontSize: CGFloat) -&gt; UIFont {
    // 首次初始化
    if cachedFont == nil { cachedFont = [String: UIFont]() }
    let hashKey = &quot;\(fontName.rawValue)\(fontSize)&quot;
    if let tempFont = UIFont.cachedFont?[hashKey] {
        return tempFont
    } else {
        let customFont = UIFont(name: fontName.rawValue, size: fontSize) ?? UIFont.fontWithSize(fontSize)
        UIFont.cachedFont?[hashKey] = customFont
        return customFont
    }
}
}   
</code></pre>
<pre><code>// 修改代码
static let customFontCached: YYMemoryCache? = {
    let memoryCache = YYMemoryCache()
    memoryCache.name = &quot;qm.CustomFontCache&quot;
    memoryCache.shouldRemoveAllObjectsWhenEnteringBackground = false
    memoryCache.shouldRemoveAllObjectsOnMemoryWarning = false
    return memoryCache
}()

// 缓存字体的方法
private static func getCachedFont(_ fontName: FontType, fontSize: CGFloat) -&gt; UIFont {
    let hashKey = &quot;\(fontName.rawValue)\(fontSize)&quot;
    if let tempFont = customFontCached?.object(forKey: hashKey) as? UIFont {
        return tempFont
    } else {
        let customFont = UIFont(name: fontName.rawValue, size: fontSize) ?? UIFont.fontWithSize(fontSize)
        customFontCached?.setObject(customFont, forKey: hashKey)
        return customFont
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[聊一聊 Bitcode]]></title>
        <id>https://mumuwanglin.github.io/post/liao-yi-liao-bitcode/</id>
        <link href="https://mumuwanglin.github.io/post/liao-yi-liao-bitcode/">
        </link>
        <updated>2020-09-05T06:27:07.000Z</updated>
        <content type="html"><![CDATA[<p>2015 年起，苹果允许你可以选择是否在你的 iOS 应用或 SDK 上是否包含 Bitcode。为了消除大家对 Bitcode 的疑惑，我们来讨论以下几点：</p>
<h2 id="什么是-bitcode">什么是 Bitcode？</h2>
<p>想知道什么是 Bitcode，我们先来回顾下编译过程。编译器会在编译时将可读代码转为计算机或手机可执行的机器码。 编译过程有下面三个不同的步骤：</p>
<ol>
<li>编译器前端将源代码转换成某种中间产物 Intermediate representation (IR)；</li>
<li>优化器执行一个优化队列来对中间产物 (IR) 进行优化，使它变得更小更高效：移除冗余代码、对结果进行预先计算、内联代码等等。编译过程中的这个关键步骤使用的就是中间产物 (IR)，而不是源代码或机器码，因为它更容易的被优化器来解释（这句话我的意思可能表达的不太对，欢迎指正）；</li>
<li>编译器后端会根据优化后的中间产物生成机器码。</li>
</ol>
<p>所以当我们聊到 Bitcode，实际上是在说这种由 Clang 编译器使用的中间产物（或者更准确的来说，是这种编译器的中间产物在磁盘中的表现形式）。Clang 广泛使用在基于 LLVM 框架的 C/C++/Objective-C 语言家族的编译器上，它同样被苹果在 Xcode 中用来编译 iOS 和 macOS 应用。所以 Bitcode 并不是什么新奇的东西，因为它一直存在于 LLVM 框架的编译器中。</p>
<h2 id="构建你的-bitcode-enable-项目">构建你的 Bitcode-enable 项目：</h2>
<p>2015 年，苹果添加了是否在你的应用编译过程中嵌入 Bitcode 的选项。当禁用这个选项的时候，编译器只会生成包含机器码的可执行文件。<br>
<img src="https://mumuwanglin.github.io/post-images/1617085679372.png" alt="" loading="lazy"><br>
但如果选中了这个选项，Bitcode 会连同机器码一起被包含在可执行文件中。<br>
<img src="https://mumuwanglin.github.io/post-images/1617085692143.png" alt="" loading="lazy"><br>
当执行嵌入了 Bitcode 的应用，Bitcode 会被忽略，应用程序会以和运行普通可执行文件相同的方式来运行机器码。</p>
<h2 id="苹果在嵌入-bitcode-的时候做了什么">苹果在嵌入 Bitcode 的时候做了什么？</h2>
<p>为什么苹果会提供嵌入 Bitcode 的选项呢？答案是显而易见的。将 Bitcode 嵌入进可执行文件，苹果能在不通过开发者交互的情况下重编译应用。优点如下：</p>
<ol>
<li>苹果在不断加强 Clang 编译器的优化，以便进一步提高 iOS 应用的性能。通过嵌入 Bitcode，苹果能使用最新的、升级过的编译器重编译应用。这将简化开发者更新他们的开发环境、重编译再到上传应用到 App Store 的这这一套流程。</li>
<li>嵌入 Bitcode，开发者能自动迁移他们的 App 到最新的设备上。嵌入 Bitcode 使苹果能够重新编译现有的应用程序，并使它们与新设备的芯片组兼容。</li>
</ol>
<h2 id="嵌入-bitcode-安全么是否有安全隐患">嵌入 Bitcode 安全么？是否有安全隐患？</h2>
<p>嵌入 Bitcode 过程中的关键信息永远不会被发送到用户的手机上。苹果将 Bitcode 储存在其远端服务器上，并在需要的时候才会去使用它。换句话说，只用苹果能访问到该 Bitcode，用户不会体验到是否嵌入 Bitcode 前后 App 的区别，而且 Bitcode 从来没有离开过苹果的服务器。这是极其安全的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swift：记录UILabel的扩展，计算label的实际高度以及行数]]></title>
        <id>https://mumuwanglin.github.io/post/swiftji-lu-uilabel-de-kuo-zhan-ji-suan-label-de-shi-ji-gao-du-yi-ji-xing-shu/</id>
        <link href="https://mumuwanglin.github.io/post/swiftji-lu-uilabel-de-kuo-zhan-ji-suan-label-de-shi-ji-gao-du-yi-ji-xing-shu/">
        </link>
        <updated>2020-07-03T06:18:36.000Z</updated>
        <content type="html"><![CDATA[<p>项目中常用到label的实际高度，有时也会需要知道label的实际行数是多少，系统的numberOfLines属性，只是设置label的最多显示的行数，而不是实际的行数。<br>
我们写一个label的扩展，把需要的值作为属性计算出来，我们知道，在swift中，是可以使用计算属性的。</p>
<pre><code>import Foundation

extension UILabel {
    
    /// UILabel根据文字的需要的高度
    public var requiredHeight: CGFloat {
        let label = UILabel(frame: CGRect(
            x: 0,
            y: 0,
            width: frame.width,
            height: CGFloat.greatestFiniteMagnitude)
        )
        label.numberOfLines = 0
        label.lineBreakMode = .byWordWrapping
        label.font = font
        label.text = text
        label.attributedText = attributedText
        label.sizeToFit()
        return label.frame.height
    }
    
    /// UILabel根据文字实际的行数
    public var lines: Int {
        return Int(requiredHeight / font.lineHeight)
    }
}
</code></pre>
<p>使用：<br>
<code>nameLabel.numberOfLines = nameLabel.lines &gt; 1 ? 2 : 1</code></p>
<p>注意：<br>
如果你是使用autolayout进行布局的，在使用这个属性的时候，一定要保证label的frame是正确的，尤其是宽度，一定要是准确的。如果不准确，请使用layoutIfNeeded()，确定一下frame，在使用计算属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 如何优雅的判断内存泄漏]]></title>
        <id>https://mumuwanglin.github.io/post/ios-ru-he-you-ya-de-pan-duan-nei-cun-xie-lou/</id>
        <link href="https://mumuwanglin.github.io/post/ios-ru-he-you-ya-de-pan-duan-nei-cun-xie-lou/">
        </link>
        <updated>2020-06-22T06:00:24.000Z</updated>
        <content type="html"><![CDATA[<p>视图控制器是通常发生内存泄漏的一个组件，因为它是将许多代码粘合在一起的组件。一个错误，最终导致泄漏。</p>
<p><code>Apple</code>提供了一种复杂的工具来调试内存泄漏，例如<code>Instrument</code>，但是这不是我所使用的工具。当我怀疑视图控制器中存在泄漏时，我将使用<code>printin deinit</code>方法。</p>
<pre><code>deinit {
    print(&quot;deinit \(self)&quot;)
}
</code></pre>
<p>如果有泄漏，deinit将不会被执行，也不会打印任何内容。即使它不是很优雅，但多年来我一直使用。</p>
<h2 id="更好的方法">更好的方法</h2>
<p>最近，我发现了一个非常好的技巧。</p>
<p>使用符号断点来检测未释放的视图控制器。与我的概念相同print，但是更加整洁。您不会用print这种方式填充代码。</p>
<ol>
<li>
<p>转到<code>Breakpoint Navigator</code>（菜单视图&gt;导航器&gt;显示<code>Breakpoint Navigator</code>或<code>command + 8</code>）<br>
<img src="https://mumuwanglin.github.io/post-images/1617084121428.png" alt="" loading="lazy"></p>
</li>
<li>
<p>单击+并选择符号断点...或菜单调试&gt;断点&gt;创建符号断点...<br>
<img src="https://mumuwanglin.github.io/post-images/1617084263696.png" alt="" loading="lazy"></p>
</li>
<li>
<p>设置Symbol值 <code>-[UIViewController dealloc]。</code><br>
<img src="https://mumuwanglin.github.io/post-images/1617084299492.png" alt="" loading="lazy"></p>
</li>
<li>
<p>单击添加操作按钮，然后将其设置Sound为pop（或您喜欢的任何声音）。<br>
<img src="https://mumuwanglin.github.io/post-images/1617084323778.png" alt="" loading="lazy"></p>
</li>
<li>
<p>单击我们的声音操作旁边的+，添加其他操作。</p>
</li>
<li>
<p>将Log Message视图控制器释放后，将操作设置为，并将消息设置为要打印到控制台的任何内容。就我而言，我将其设置为<code>--- dealloc @(id)[$arg1 description]@</code>。<br>
<img src="https://mumuwanglin.github.io/post-images/1617084359862.png" alt="" loading="lazy"></p>
</li>
<li>
<p>选中Automatically continue after evaluating actions选项，因为我们不希望调试器在释放视图控制器时暂停。<br>
<img src="https://mumuwanglin.github.io/post-images/1617084391145.png" alt="" loading="lazy"></p>
</li>
<li>
<p>最终配置<br>
<img src="https://mumuwanglin.github.io/post-images/1617084673829.png" alt="" loading="lazy"></p>
</li>
</ol>
<h2 id="检测泄漏">检测泄漏</h2>
<p>使用此断点后，只要视图控制器关闭导航框或从导航堆栈中弹出，便会听到弹出声和调试控制台中的登录信息。这意味着一切都按预期进行。<br>
如果您弹出或关闭视图控制器，但听不到弹出的声音，则意味着存在泄漏。</p>
<h2 id="结论">结论</h2>
<p>这是最终的符号断点值。</p>
<table>
<thead>
<tr>
<th>Field</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Symbol</td>
<td>-[UIViewController dealloc]</td>
</tr>
<tr>
<td>Module</td>
<td>留空或 UIKitCore</td>
</tr>
<tr>
<td>Action: Sound</td>
<td>pop 或任何你喜欢的声音</td>
</tr>
<tr>
<td>Action: Log Message</td>
<td>--- dealloc @(id)[$arg1 description]@ 或您想在调试控制台中打印的内容</td>
</tr>
<tr>
<td>Options</td>
<td>检查一下 Automatically continue after evaluatin</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WKWebview使用攻略]]></title>
        <id>https://mumuwanglin.github.io/post/wkwebview-shi-yong-gong-lue/</id>
        <link href="https://mumuwanglin.github.io/post/wkwebview-shi-yong-gong-lue/">
        </link>
        <updated>2020-06-10T06:20:15.000Z</updated>
        <content type="html"><![CDATA[<p>现在我们的app都需要使用WKWebview来加载h5页面了,但是使用过程中有些细节需要注意,通过本篇文章可以让大家更加完善的了解WKWebview的使用。</p>
<hr>
<p>iOS8.0之后我们可以使用WebKit框架中的WKWebView来加载网页，WKWebView可将网页处理限制在App的网页视图中，从而确保不安全的网站内容不会影响到App的其他部分，并且苹果表示2020年12月起将不再接受使用UIWebView的App更新，因此我对WKWebView的使用方法及在使用WKWebView的过程中遇到的问题进行了总结。</p>
<p>首先WKWebView的优点很多了，内存开销比UIWebView小很多，支持了更多的HTML5特性，流程粒度上更加细致，可以在请求时候询问是否请求数据还可以在返回数据后询问是否加载数据，在返回错误时候也更加细致。</p>
<h2 id="创建wkwebview">创建WKwebview</h2>
<pre><code>- (WKWebView *)webView {
    if (_webView) {
        return _webView;
    }
    WKUserContentController *userContentController = [[WKUserContentController alloc] init];
    [userContentController addScriptMessageHandler:[[WKWeakScriptMessageDelegate alloc] initWithDelegate:self] name:@&quot;jsCallOC&quot;];
    WKWebViewConfiguration* webViewConfig = [[WKWebViewConfiguration alloc] init];
    webViewConfig.userContentController = userContentController;
    webViewConfig.processPool = [[self cookieManager] sharedProcessPool];
    webViewConfig.allowsInlineMediaPlayback = true;
    
    _webView = [[WKWebView alloc] initWithFrame:CGRectMake(0,
                                                           CGRectGetHeight(self.iTopBar.frame),
                                                           self.view.bounds.size.width,
                                                           (self.view.bounds.size.height - CGRectGetHeight(self.iTopBar.frame))) configuration:webViewConfig];
    _webView.backgroundColor = [UIColor whiteColor];
    _webView.scrollView.backgroundColor = [UIColor blackColor];
    _webView.opaque = NO;
    _webView.scrollView.showsHorizontalScrollIndicator = NO;
    _webView.scrollView.showsVerticalScrollIndicator = NO;

    _webView.opaque = NO;
    _webView.autoresizingMask = UIViewAutoresizingFlexibleHeight | UIViewAutoresizingFlexibleWidth;
    _webView.scrollView.bounces = !self.disableBounces;
    _webView.UIDelegate = self;
    _webView.navigationDelegate = self;
    return _webView;
}
</code></pre>
<p>其中：</p>
<ul>
<li>WKWebViewConfiguration 用来添加WKWebView的一些配置信息，包括交互的userContentController，进程池processPool及一些其他的属性</li>
<li>WKUserContentController 这个类主要用处理JavaScript向webview发送消息的交互，addScriptMessageHandler方法注册了一个名为jsCallOC的方法用来和H5进行交互，具体的交互的方法名可以两端统一即可</li>
<li>webViewConfig.allowsInlineMediaPlayback = YES;这个属性是支持视频页面内播放，这里注意下，不设置这个属性会导致页面内的视频都是打开视频播放器全屏播放的，使用UIWebview时候没有这个问题，所以提醒大家在使用WKWebview时候注意一下</li>
</ul>
<h2 id="wkwebview的主要代理方法">WKWebview的主要代理方法</h2>
<p>WKNavigationDelegate主要是处理一些跳转、加载处理操作，WKUIDelegate主要处理JS脚本，确认框，警告框等。</p>
<p>WKNavigationDelegate常用代理方法：</p>
<pre><code>/** 开始请求服务器并加载页面 */
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;
/** 开始渲染页面时调用，响应的内容到达主页面的时候响应,刚准备开始渲染页面*/
- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation;
/** 页面渲染完成后调用 */
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;
/** 页面加载出错调用 */
- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error;
/** 请求服务器发生错误 (如果是goBack时，当前页面也会回调这个方法，原因是NSURLErrorCancelled取消加载) */
- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation withError:(NSError *)error;
/** 是否允许页面加载 */
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;
/** 接收到服务器跳转请求即服务重定向时之后调用 */
- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation;
/** 收到服务器响应后，决定是否跳转 */
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;
</code></pre>
<p>其中decidePolicyForNavigationAction相当于uiwebview的shouldStartLoadWithRequest方法，在这个方法里可以对页面跳转进行拦截处理，decisionHandler(WKNavigationActionPolicyAllow)是允许跳转，decisionHandler(WKNavigationActionPolicyCancel)是取消跳转，注意当处理情况比较多时候执行完decisionHandler()这个回调后要加上return，否则会引起崩溃。</p>
<p>WKUIDelegate常用代理方法：</p>
<pre><code>其中decidePolicyForNavigationAction相当于uiwebview的shouldStartLoadWithRequest方法，在这个方法里可以对页面跳转进行拦截处理，decisionHandler(WKNavigationActionPolicyAllow)是允许跳转，decisionHandler(WKNavigationActionPolicyCancel)是取消跳转，注意当处理情况比较多时候执行完decisionHandler()这个回调后要加上return，否则会引起崩溃。

WKUIDelegate常用代理方法：
</code></pre>
<p>这里注意下，在使用WKWebview时发现有些三方播放页面点击链接不跳转的问题，查阅相关资料后发现，用户点击网页上的链接，需要打开新页面时，将先调用decidePolicyForNavigationAction方法，其中的WKNavigationAction有两个属性sourceFrame和targetFrame，类型是WKFrameInfo，WKFrameInfo的mainFrame属性标记着这个frame是在主frame里还是新开一个frame。</p>
<p>如果 targetFrame的mainFrame属性为NO，将会新开一个页面，WKWebView遇到这种情况，将会调用它的 WKUIDelegate代理中的createWebViewWithConfiguration方法，所以如果我们不实现这个协议就会出现点击无反应的情况，因此对于这种情况需要特殊处理，可以采取下边的方法：</p>
<pre><code>-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {
    if (!navigationAction.targetFrame.isMainFrame) {
        [webView loadRequest:navigationAction.request];
    }
    return nil;
}
</code></pre>
<p>相当于放弃原来页面直接打开新的页面。</p>
<h2 id="wkwebview注册useragent">WKWebview注册UserAgent</h2>
<p>如果需要⾃定义UA的话WKWebview注册UA时应该区分iOS9以下和iOS9以上分开设置，对于系统 &gt;=iOS9.0的可采⽤：</p>
<pre><code>[webView evaluateJavaScript:@&quot;navigator.userAgent&quot; completionHandler:^(id obj, NSError *error) {
 if([obj isKindOfClass:[NSString class]]){
  NSString * userAgent = obj; 
  if(![userAgent containsString:@&quot;customUA&quot;]){
   userAgent = [userAgent stringByAppendingString:@&quot;customUA&quot;];
  }
  [[NSUserDefaults standardUserDefaults] registerDefaults:@{ @&quot;UserAgent&quot;: userAgent OR @&quot;&quot;}];
     [[NSUserDefaults standardUserDefaults] setObject:userAgent forKey:uaKey];
     self.webView.customUserAgent = userAgent;
 }
}];
</code></pre>
<p>对于iOS8系统使用下边方法</p>
<pre><code>[self.webView setValue: userAgent forKey:@&quot;applicationNameForUserAgent&quot;];
</code></pre>
<p>否则在ios8系统上会引起崩溃</p>
<h2 id="种cookie">种cookie</h2>
<p>因为WKWebview不会像UIWebview那样每次在请求之前会将NSHTTPCookieStorage里面的cookie自动添加到请求中，所以应采用将cookie通过js注入到WKWebview中的方法，我采用了https://www.jianshu.com/p/277c2141303d博客中提到的使用同一个processPool的方法，创建了两个WKWebView，其中的一个用来加载h5，另一个专门用来加载cookie，解决了WKWebview种cookie的问题。</p>
<p>由于UIWebview的Cookie是由NSHTTPCookieStorage管理的，NSHTTPCookieStorage是一个单例可以管理整个项目的Cookie，在请求时候会自动带上上次保存的Cookie，但是WKWebview的Cookie信息并不存储在NSHTTPCookieStorage中，是由WKProcessPool管理的，所以对于多个WKWebview之间可以通过将WKProcessPool单例化来解决Cookie共享的问题。</p>
<p>设置cookie可在第一次请求host时使用一个cookieWebview来加载并设置好cookie，然后再使用self.webview来继续加载url，self.webview与cookieWebview共用单例sharedProcessPool，因此可以解决WKWebview种cookie的问题。</p>
<p>为方便管理可以使用WKWebViewCookieManager来单独实现cookie的逻辑：</p>
<pre><code>- (void)setCookieWithUrl:(NSURL *)url {
    NSString *host = [url host];
    
    if (!self.webviewCookie.length) {
        [self requestWKWebviewCookie];
        return;
    }
    
    if ([self.cookieURLs containsObject:host]) {
        return;
    }
    [self.cookieURLs addObject:host];
    
    WKUserScript *wkcookieScript = [[WKUserScript alloc] initWithSource:self.webviewCookie
                                                          injectionTime:WKUserScriptInjectionTimeAtDocumentStart
                                                       forMainFrameOnly:NO];
    [self.cookieWebview.configuration.userContentController addUserScript:wkcookieScript];
    
    NSString *baseWebUrl = [NSString stringWithFormat:@&quot;%@://%@&quot;, url.scheme, url.host];
    [self.cookieWebview loadHTMLString:@&quot;&quot; baseURL:[NSURL URLWithString:baseWebUrl]];
}

- (WKWebView *)cookieWebview {
    if (!_cookieWebview) {
        WKUserContentController *userContentController = WKUserContentController.new;
        WKWebViewConfiguration* webViewConfig = WKWebViewConfiguration.new;
        webViewConfig.userContentController = userContentController;
        webViewConfig.processPool = [self sharedProcessPool];
        
        _cookieWebview = [[WKWebView alloc] initWithFrame:CGRectZero configuration:webViewConfig];
        _cookieWebview.UIDelegate = self;
        _cookieWebview.navigationDelegate = self;
    }
    return _cookieWebview;
}
</code></pre>
<h2 id="native与h5的交互">Native与H5的交互</h2>
<ul>
<li>js与OC交互<br>
js向OC传值的方法有两种，一种是通过拦截url，可以通过拦截url中的字段来进行处理，有些情况下通过url传参数比较方便，可以及时处理参数减少打开h5页面的延迟，但是需要视具体业务逻辑来处理，有的可能通过url传参数无法兼容老的版本或者有其他的问题，这种情况则可以使用另一种方法处理。</li>
</ul>
<pre><code>- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    NSURL *url = navigationAction.request.URL;
    if ([url.scheme isEqualToString:@&quot;sv&quot;]) {
     //do something。。。
     decisionHandler(WKNavigationActionPolicyAllow);
      return;
    }else{
     //do other things。。。
     decisionHandler(WKNavigationActionPolicyAllow);
      return;
    }
}
</code></pre>
<p>另一种是使用WKScriptMessageHandler代理方法，通过和js约定好调用方法，在创建webview时候监听jsCallOC方法</p>
<pre><code>- (void)userContentController:(WKUserContentController *)userContentController
      didReceiveScriptMessage:(WKScriptMessage *)message {
    NSLog(@&quot;[WebView] : H5对客户端发起调用 name : %@, body : %@&quot;, message.name, message.body);
    
    if([message.name isEqualToString:@&quot;jsCallOC&quot;] &amp;&amp; [message.body isKindOfClass:[NSString class]]){
    NSDictionary *result = [message.body JSONDictionary];
    NSString *value = [result stringOrEmptyStringForKey:@&quot;value&quot;];//value为h5传过来的值
    //do something。。。
    }
}
</code></pre>
<p>js端调用方法为如下，注意传值时候的JSON格式处理，处理不正确会出现传值失败无法调用成功的问题<br>
<code>window.webkit&amp;&amp;window.webkit.messageHandlers.jsCallOC.postMessage(JSON.stringify(data));</code></p>
<ul>
<li>OC与js交互 OC调用js的方法就比较简单如下</li>
</ul>
<pre><code>NSString * OCCallJs = [NSString stringWithFormat:@&quot;OCCallJs('%@')&quot;, value];//注意调用js方法传参数要加上单引号！！！
[self.webView evaluateJavaScript:OCCallJs completionHandler:^(id result, NSError *error) {
                
}];
</code></pre>
<h2 id="wkwebview注册useragent-2">WKWebview注册UserAgent</h2>
<ul>
<li>NSURLRequest的缓存策略</li>
</ul>
<pre><code>typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)
{
    NSURLRequestUseProtocolCachePolicy = 0, // 默认策略
    NSURLRequestReloadIgnoringLocalCacheData = 1, // 忽略本地缓存，直接从后台请求数据
    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, // 系统未实现，忽略本地缓存数据、代理和其他中介的缓存，直接从后台请求数据
    NSURLRequestReturnCacheDataElseLoad = 2, // 只有在cache中不存在data时才从原始地址下载
    NSURLRequestReturnCacheDataDontLoad = 3,  // 只从本地拿数据,如果不存在本地缓存，请求失败
    NSURLRequestReloadRevalidatingCacheData = 5, // 验证本地数据与远程数据是否相同，如果不同则下载远程数据，否则使用本地数据
};
</code></pre>
<p><img src="https://mumuwanglin.github.io/post-images/1617085558311.webp" alt="" loading="lazy"><br>
默认策略NSURLRequestUseProtocolCachePolicy：如果一个NSCachedURLResponse对于请求并不存在，则直接从源端取数据。如果请求拥有一个缓存的响应，那么URL加载系统会检查这个响应来决定，如内容必须重新验证的话，将建立一个连向源端的连接来查看内容是否发生变化。假如内容没有变化，那么响应就从本地缓存返回数据。如果内容变化了，那么数据将从源端获取。</p>
<ul>
<li>对于缓存的响应过期或者需要重新验证的情况，可以通过HTTP中请求和响应头来判断：</li>
</ul>
<ol>
<li>
<p>Cache-Control<br>
如响应头部包括的Cache-Control，服务器需要根据Cache-Control这个响应头来指定缓存策略，Cache-Control的选项中no-store的优先级最高，其他值可以相互组合，public表示响应可被任何缓存区缓存；private内容仅客户端可以缓存；no-cache不能缓存；must-revalidation如果缓存失效必须发送head到服务器进行验证；max-age可以接收生存期不大于指定时间（以秒为单位）的资源；min-fresh可以接收响应时间小于指定时间内更新过的资源；max-stale可以接收超出时限的资源</p>
</li>
<li>
<p>Expires<br>
表示缓存存在时间，允许客户端在这个时间之前不去发请求<br>
<img src="https://mumuwanglin.github.io/post-images/1617085595345.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Last-Modified与If-Modified-Since<br>
Last-Modified表示资源最后修改时间，发送请求时app会向服务端发送If-Modified-Since，服务器接收到带有该请求头的请求时，将该时间与服务端最后修改时间比较，如果一致，则直接返回304状态码，客户端直接使用本地的缓存。否则返回200和修改后的资源和新的时间。</p>
</li>
<li>
<p>Etag与If-None-Match<br>
这两个值主要从来标识资源是否更新，如果资源过期且有Etag标识时，请求时将其作为If-None-Match带上，服务端收到后进行对比校验，一致则返回304，客户端使用本地缓存，不一致则返回资源。</p>
</li>
</ol>
<p>关于WKwebview的用法及注意点如上总结完毕，如果大家有更多的建议欢迎随时沟通哦~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS 自定义present动画（Swift）]]></title>
        <id>https://mumuwanglin.github.io/post/ios-zi-ding-yi-present-dong-hua-swift/</id>
        <link href="https://mumuwanglin.github.io/post/ios-zi-ding-yi-present-dong-hua-swift/">
        </link>
        <updated>2020-05-30T06:13:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>因为项目需要，Present动画需要支持下滑和侧滑返回，所以自定义了present动画。</p>
<h2 id="正文">正文</h2>
<p>想要实现不一般又炫酷的present过渡动画，则必须使用自定义动画了，主要就是 UIViewControllerAnimatedTransitioning这个协议中进行具体的动画操作。</p>
<p>网上也看过其他人写的，虽然确实挺花俏的，但是真正导入项目的时候有些不可用，最典型的问题就是 影响了原有的代码，还有就是只支持一次性展示效果，达不到多层次效果，比如present一个controllerA之后，再从controllerA present到controllerB。为了完善一下，特地整理了一下项目中的分享给大家, <a href="https://github.com/mumuwanglin/YYPullDownGesture">Demo地址</a></p>
<p>当然，为这个只是针对present模态展示的。总共用到的效果有定义为二种</p>
<pre><code>enum YYTransformType: NSInteger {
    case present
    case dismiss
}
</code></pre>
<h2 id="组成部分">组成部分</h2>
<ol>
<li>控制器分类，如果想要使用这个效果，则直接yy_present即可</li>
</ol>
<pre><code>var yy_presentAnimation: Bool? { get set }
var yy_presentKey: String? { get set }
func yy_present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&gt; Void)?);
func removePresentAnimator()
</code></pre>
<ol start="2">
<li>对象管理记具体实施者</li>
</ol>
<pre><code>class YYPresentAnimatorManager {
    
    static let shared = YYPresentAnimatorManager()
    
    private lazy var animatorDict: NSMutableDictionary = NSMutableDictionary()
    
    // 存储动画器
    func addAnimtor(animator: YYPresentAnimator, key: String) {
        animatorDict.setObject(animator, forKey: key as NSString)
    }
    
    // 移除动画器
    func removeAnimator(key: String) {
        if animatorDict.count == 0 {
            return
        }
        if key.count == 0 {
            return
        }
        
        animatorDict.removeObject(forKey: key)
    }
    
}
</code></pre>
<ol start="3">
<li>具体动画实现方式</li>
</ol>
<pre><code> func presentAnimation(transitionContext: UIViewControllerContextTransitioning) {
        let fromView = transitionContext.view(forKey: .from)
        let toView = transitionContext.view(forKey: .to)
        
        toView?.frame = transitionContext.containerView.bounds
        if let toView = toView {
            transitionContext.containerView.addSubview(toView)
        }
        
        let toWidth: CGFloat = toView?.bounds.size.width ?? 0
        let toHeight: CGFloat = toView?.bounds.size.height ?? 0
        toView?.frame = CGRect(x: 0, y: toHeight, width: toWidth, height: toHeight)
                
        UIView.animate(withDuration: transitionDuration(using: transitionContext), animations: {
            toView?.frame = CGRect(x: 0, y: 0, width: toWidth, height: toHeight)
        }) { (finished) in
            transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
            fromView?.layer.zPosition = 0
            fromView?.layer.transform = CATransform3DIdentity
        }
}
</code></pre>
]]></content>
    </entry>
</feed>